\documentclass[a4wide,12pt]{report}

\usepackage[romanian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}
\usepackage{tikz}
% Use Open Sans as the sans serif font.
\usepackage[defaultsans,osfigures,scale=0.95]{opensans}
\usepackage[T1]{fontenc}
\usepackage{color}
\usepackage{relsize}        % Pentru mărimi relative de text.
\usepackage{pgfplots}

\renewcommand{\seriesdefault}{l}

% Opțiuni la diagrame tikz.
\usetikzlibrary{patterns, trees, matrix, arrows, decorations.pathmorphing,
decorations.pathreplacing, plotmarks}

% Comenzi
\newcommand{\eng}[1]{\emph{#1}} % Pentru cuvinte în limba engleză.
\newcommand{\cod}[1]{\texttt{#1}}
\newcommand{\url}[1]{\texttt{#1}}
\newcommand{\uplu}[1]{$\langle$#1$\rangle$}
\newcommand{\floor}[1]{\lfloor{}#1\rfloor} % Pentru trunchiere.
\newcommand{\acr}[1]{{\textsmaller[1]{\textsc{#1}}}} % Pentru acronime.
\newcommand{\idee}[1]{{\color{red} #1}}
\newcommand{\poate}[1]{#1}

\newcommand{\capfara}[1]{
    \chapter*{#1}
    \addcontentsline{toc}{chapter}{#1}
}

\newcommand{\secfara}[1]{
    \section*{#1}
    \addcontentsline{toc}{section}{#1}
}

% Variabile
\newcommand{\subtitlu}{editor web colaborativ de \LaTeX}
\newcommand{\titlu}{Multilatex: \subtitlu}
\newcommand{\autor}{Paul Răzvan Nechifor} % Ăsta-s io. :)
\newcommand{\coordonator}{conf. dr. Sabin-Corneliu Buraga}
\newcommand{\sesiunea}{iulie, 2014}
\newcommand{\datacurenta}{\today}
\newcommand{\loculsisemnatura}{
    \vspace{20mm}
    \noindent
    Iași, \datacurenta
    \vspace{20mm}
    \begin{flushright}
        Absolvent \emph{\autor}\\
        \setlength{\unitlength}{1cm}
        \begin{picture}
            (4, 1)\put(0, 0)
            {\line(1, 0){4}}
        \end{picture}
        \vspace{5mm}\\
        (semnătura în original)
    \end{flushright}
}

\begin{filecontents*}{statcounter.csv}
in out
2009.0  0.67
2009.5  1.05
2010.0  1.56
2010.5  2.86
2011.0  4.30
2011.5  7.02
2012.0  8.49
2012.5  11.09
2013.0  14.13
2013.5  17.35
2014.0  23.00
\end{filecontents*}

\begin{document}
\frenchspacing % Don't use double spacing.
\onehalfspace % Larger line space.

\fontdimen2\font=5.00pt % Interword space (default 3.91663pt).
\fontdimen3\font=2.00pt % Interword stretch (default 1.95831pt).
\fontdimen4\font=1.50pt % Interword shrink (default 1.30554pt).
\fontdimen7\font=0.00pt % Extra space (default 1.30554pt).

\pagestyle{empty} % Hide page number.

% Cover background color.
\begin{tikzpicture}[overlay]
    \definecolor{albastru de fii}{rgb}{0.176, 0.447, 0.713}
    \fill [fill=albastru de fii] (-5,5) rectangle (21.0,-29.7);
\end{tikzpicture}

\begin{figure}[!htb]
\minipage{2cm}
    \includegraphics[width=2cm]{imagini/uaic}
\endminipage\hfill
\minipage{11cm}
    \centering
    \color{white}
    \large{\textsf{Universitatea Alexandru Ioan Cuza Iași}}

    \LARGE{\textsf{Facultatea de Informatică}}

    \large{\textsf{Master Ingineria Sistemelor Software}}
\endminipage\hfill
\minipage{2cm}%
    % FCS logo.
    \begin{tikzpicture}[scale=0.26]
        \def\taie{0.5}
        \definecolor{alb}{rgb}{1, 1, 1}

        \fill [fill=alb]
            (0,0) -- (2,0) -- (2,3) -- (3,3) -- (5,5) -- (2,5) --
            (2,6) -- (6,6) -- (8,8) -- (0,8) -- cycle;
        \fill [fill=alb]
            (3,0) -- (3,3-\taie) -- (5,5-\taie) -- (5,0) -- cycle;
        \fill [fill=alb]
            (6,0) -- (6,6-\taie) -- (8,8-\taie) -- (8,0) -- cycle;
    \end{tikzpicture}
\endminipage
\end{figure}

\vspace{2cm}

\begin{center}
    \centering
    \color{white}
    {\fontsize{22}{26}\selectfont \textsf{LUCRARE DE DIZERTAȚIE}}\\
    \vspace{1.5cm}
    {\fontsize{40}{46}\selectfont \textsf{\textbf{Multilatex}}}\\
    \vspace{0.5cm}
    {\fontsize{26}{28}\selectfont \textsf{\subtitlu}}\\
    \vspace{1.5cm}
    \large{\textsf{propusă de}}\\
    \vspace{1.5cm}
    {\fontsize{26}{28}\selectfont \textsf{Paul Răzvan \textbf{Nechifor}}}\\
    \vspace{1.5cm}
    {\fontsize{16}{26}\selectfont \textsf{\textbf{Sesiunea:} \sesiunea}}\\
    \vspace{1.5cm}
    {\fontsize{14}{26}\selectfont \textsf{Coordonator științific}}\\
    {\fontsize{18}{26}\selectfont \textsf{\textbf{\coordonator}}}\\
\end{center}

\pagebreak

% Pagina de titlu
\begin{center}
    \textbf{UNIVERSITATEA ALEXANDRU IOAN CUZA IAȘI}\\
    \vspace{3mm}
    \textbf{FACULTATEA DE INFORMATICĂ}\\
    \vspace{89mm}
    \Huge{\textbf{\titlu}}\\
    \vspace{30mm}
    \Large{\textbf{\emph{\autor}}}\\
    \vspace{11mm}
    \Large{\textbf{Sesiunea:} \sesiunea}\\
    \vspace{10mm}
    \normalsize{Coordonator științific}\\
    \vspace{3mm}
    \large{\textbf{\coordonator}}\\
    \end{center}
\pagebreak

\section*{Declarație privind originalitate și respectarea drepturilor de autor}

Prin prezenta declar că lucrarea de licență cu titlul „\titlu“ este scrisă de
mine și nu a mai fost prezentată niciodată la o altă facultate sau instituție de
învățământ superior din țară sau străinătate. De asemenea, declar că toate
sursele utilizate, inclusiv cele preluate de pe internet, sunt indicate în
lucrare, cu respectarea regulilor de evitare a plagiatului:

\begin{itemize}

\item toate fragmentele de text reproduse exact, chiar și în traducere proprie
din altă limbă, sunt scrise între ghilimele și dețin referința precisă a sursei;

\item reformularea în cuvinte proprii a textelor scrise de către alți autori
deține referința precisă;

\item codul sursă, imagini etc. preluate din proiecte cu sursă publică sau alte
surse sunt utilizate cu respectarea drepturilor de autor și dețin referințe
precise;

\item rezumarea ideilor altor autori precizează referința precisă la textul
original.

\end{itemize}

\loculsisemnatura

\pagebreak

\section*{Declarație de consimțământ}
Prin prezenta declar că sunt de acord ca lucrarea de licență cu titlul „\titlu“,
codul sursă al programelor și celelalte conținuturi (grafice, multimedia, date
de test etc.) care însoțesc această lucrare să fie utilizate în cadrul
Facultății de Informatică.

De asemenea, sunt de acord ca Facultatea de Informatică de la Universitatea
Alexandru Ioan Cuza Iași să utilizeze, modifice, reproducă și să distribuie în
scopuri necomerciale programele-calculator, format executabil și sursă,
realizate de mine în cadrul prezentei lucrări de licență.

\loculsisemnatura

\pagebreak

% Cuprins
\pagestyle{plain}
\setcounter{page}{1} % Începe numerotarea de la 1.

\tableofcontents

\pagebreak

\capfara{Introducere}

\secfara{Motivație}

\capfara{Contribuții}

\chapter{Sisteme existente}

În acest capitol se prezintă funcționarea \TeX{} și \LaTeX{} și problemele pe care
le au. Apoi se va prezenta cum au rezolvat alții aceste deficiențe folosind tehnologii
web.

\section{\TeX}

\TeX{} este un program de compoziție tipografică care a fost început în 1977 de
către Donald Knuth pentru a permite o compoziție mai bună a articolelor și
cărților științifice.

Codul sursă pentru \TeX{}\cite{texweb} este scris în \acr{WEB}, un limbaj de
programare literară\footnote{Un tip de programare prin care codul sursă este
îmbinat cu descrierea lui astfel încât să poată fi citit similar cu o carte.}
similar cu Pascal. Folosind acest tip de programare codul sursă poate fi
compilat într-un fișier \acr{PDF}\cite{texwebpdf}.

\section{\LaTeX}

\LaTeX{} este un set generalizat de macrouri bazat pe \TeX{}.

Spre diferența de editoarele \acr{WYSIWYG}, \LaTeX{} are avantajul că permite
concentrarea pe conținut și nu pe prezentarea lui. În editoare \acr{WYSIWYG}
utilizatorii sunt tentați să folosească spații și linii goale pentru aliniere
și \eng{page breaking} pentru că editează prezentarea în loc de semantică.

Deși era un program bun la conceperea lui pe sistemele limitate de atunci,
astăzi \LaTeX{} nu exploatează avantajele aduse de sistemele moderne.

Unele dintre problemele pe care urmează să le prezint sunt rezolvate de situri
precum ShareLatex și WriteLatex. În capitolul următor am să descriu sistemul
propriu.

\subsection{Modul de lucru}

\LaTeX{} are un mod de lucru static: editarea fișierelor, compilarea,
vizualizarea documentului compilat și repetarea.

\LaTeX{} nu suportă doar recompilarea modificărilor ci necesită recompilarea
întregului document ceea ce este încet. Mai rău, sunt necesare mai multe
compilări dacă se folosește un cuprins, bibliografie, referințe și altele.

Această problemă nu poate fi rezolvată ușor deoarece ar necesita rescrierea
aplicațiilor de bază.

\subsection{Memorarea stării}
\label{memstasub}

\LaTeX{} operează prin folosirea și modificarea unor fișiere în dosarul de
lucru. Acest lucru complică orice program care vrea să-l folosească pentru că
fișierele generate sunt stocate laolaltă cu cele sursă:

\begin{itemize}

\item la curățare (eliminarea fișierelor generate) sunt multe fișiere care
trebuiesc șterse;

\item după o curățare trebuiesc efectuate un număr nespecificat de compilări
până sunt rezolvate toate referințele;

\item fișierele sursă nu pot fi prezente într-un \eng{data store} ci trebuiesc
să existe în dosar.

\end{itemize}

\subsection{Sistemul de pachete}

\LaTeX{} are suport limitat pentru pachete. Nu se specifică versiunea pachetelor
când sunt declarate în document, deci compilarea poate duce la rezultate
diferite (sau la erori) într-un mod neașteptat. Un model bun în acest caz
este Node.js unde există multe modalități de specificare a versiunii preferate
și versiuni diferite pot coexista.

În prezent sunt trei distribuții\cite{majordist} majore de \LaTeX{} cu diferite
pachete instalate implicit.

Pentru a avea o compatibilitate cât mai mare, configurarea mașinii virtuale
(secțiunea \ref{vagrantsub}, pagina~\pageref{vagrantsub}) depinde de instalarea
completă a celei mai noi versiuni de \TeX{} Live (\cod{texlive-full}) de pe
Ubuntu.

\section{ShareLatex}

\idee{TODO}

\section{WriteLatex}

\idee{TODO}

\chapter{Sistemul propus}

În acest capitol se prezintă proiectarea Multilatex și se explică în detaliu
fiecare componentă.

\section{Proiectare}

În scrierea sistemului propriu am început întâi cu proiectarea pe care am
descris-o pe situl proiectului la \cod{multilatex.com/blog} . Urmează
principalele probleme asupra cărora a trebuit să mă decid.

\subsection{Documente mari}

\LaTeX{} suportă includerea fișierelor \cod{.tex} în alte fișiere \cod{.tex}.
Prin urmare, un mod de lucru cu documente mare este să fie separate în fișiere
pe bază de capitole sau secțiuni.

Deși această variantă este suportată în Multilatex, poate fi problematică din
unele puncte de vedere: când un document este la început structura lui nu este
foarte clară și se recurge la mutarea de capitole, paragrafe etc. între
diferitele fișiere.

Principala problemă la a folosi un fișier monolitic este greutatea de navigare,
deci am ales să rezolv problema asta prin a implementa în panoul arborelui de
fișiere un nivel suplimentar prin care fișierele \cod{.tex} listează toate
capitolele, secțiunile și subsecțiunile. Astfel se poate sări ușor printre
părțile documentului.

\subsection{Editarea colaborativă}

Există două modalități de editare colaborativă: în timp real (precum Google
Docs) sau bazată pe commit-uri (precum Git sau alte sisteme de control a
versiunilor).

Deoarece \LaTeX{} nu funcționează precum un editor \acr{WYSIWYG}, a doua
variantă pare mai bună, dar operațiile de integrare ar complica mult sistemul.

Sunt probleme și la colaborarea în timp real. Aici se complică operațiile de
anulare (\eng{undo}) deoarece nu există un istoric bine definit. În plus, nu se
poate decide ușor care sunt versiunile intermediare.

Am ales până la urmă să le implementez pe ambele variante. Prima folosind
ShareJS și a doua folosind MongoDB și un \eng{file store} propriu. În
retrospectivă, acest lucru a complicat mult sistemul.

\subsection{Compararea modificărilor}

O altă problemă pe care mi-am pus-o la proiectarea a fost compararea versiunilor
intermediare și contribuțiilor de la fiecare persoană. Folosind doar
\eng{commit}-uri acest lucru este ușor, dar cu versiune în timp real este greu
să fie revizuite contribuțiile fiecărei persoane deoarece ce se pot suprapune
foarte mult.

Ca soluție am decis ca să permit \eng{commit}-uri cu mai mulți autori. Astfel
când se face un \eng{commit}, fiecare persoană care a făcut o modificare între
timp va apărea ca un autor. Dezavantajul este că nu se poate stabili pentru o
versiune ce modificare a făcut fiecare dintre autori, deci trebuiesc făcute
\eng{commit}-uri dese.

\subsection{Compilatorul de \LaTeX}

Am considerat și folosirea unui compilator de \LaTeX{} care să genereze
\acr{PDF}-urile pe partea de client. Spre exemplu \cod{texlive.js}\cite{texlivejs}
poate compila proiecte direct din navigator. Acest lucru este posibil pentru că
\TeX{} Live a fost compilat în JavaScript folosind Emscripten.

Problemele majore sunt că este prea încet și nu suportă toate pachetele \TeX{}
Live. Acest lucru chiar ar fi imposibil deoarece o instalare completă a
\cod{texlive-full} are mai mult de 2~GiB.

\subsection{Importare și exportare}

Un factor important pentru succesul unui astfel de sit este compatibilitatea și
încrederea în permanența conținutului, deci trebuie să existe un mecanism ușor
de a importa și de a exporta proiectele. Acest lucru este parțial complicat de
faptul că proiectele \LaTeX{} pot avea o multitudine de fișiere. Pentru a
rezolva această problemă am ales să consider că fișierul denumit \cod{main.txt}
sau singurul fișier \cod{.tex} este cel principal.

\subsection{Altele}

Alte probleme au fost legate de tehnologiile pe care să le folosesc pentru
construirea proiectului. Aceste programe/biblioteci vor fi prezentate mai departe
în acest capitol.

\section{Structura aplicației web}

În ceea ce urmează am să descriu cum am structurat paginile, conținutul și
organizarea sitului.

Consider că audiența principală a sitului va fi construită din persoane care au
mai folosit \LaTeX{} în trecut și doresc să se mute în \eng{cloud} și persoane
care vor să colaboreze mai bine în editarea de proiecte \LaTeX{}.

\subsection{Prima pagină}

Rolul primei pagini este de a explica într-un mod foarte rapid ce se poate face
cu acest sit și să-i convingă pe potențialii utilizatori să se înscrie. Pentru
asta am făcut posibil o înscriere cât mai rapidă (vezi
secțiunea~\ref{inregrapsub} la pagina \pageref{inregrapsub}).

Principala funcționalitate este un \eng{jumbotron} cu o demonstrație și
formularul de înregistrare rapidă.

Alte lucruri de luat în considerare ar fi recomandări de la alți utilizatori.

\subsection{Galerie}
\label{galeriesub}

Galeria prezintă cele mai populare proiecte. Într-un fel, rolul ei este de a
lista cele mai bune creații și de a demonstra ceea ce este posibil cu acest
proiect. Pagina este structurată ca o grilă de miniaturi.

Luând inspirație de la Speaker Deck, am decis să folosesc și eu o
previzualizare dinamică a proiectelor. În loc să folosesc o pagină predefinită
ca miniatură pentru un document, la compilarea unui \eng{commit} fac miniaturi
la toate paginile și mișcarea pe orizontală asupra miniaturii decide care pagină
să fie afișată. Astfel se poate previzualiza ușor un document fără să fie
deschis.

Tot aici sunt listate și șabloanele precompilate (secțiunea~\ref{sabloanesec},
pagina~\pageref{sabloanesec}) de unde pot fi și duplicate ușor.

\subsection{Utilizator}

Nu am intenționat să fac un sit social, deci pagina unui utilizator nu conține
decât metadate publice și listări a proiectelor și activității lui.

\subsection{Proiect}

Pagina proiectului conține o prezentare generală a proiectului cu toate modurile
principale de controlare a lui.

În mod proeminent este afișată lista de butoane simple pentru:

\begin{itemize}

\item accesarea editorului de proiect;

\item vizualizarea documentului \acr{PDF} rezultat

\item duplicarea proiectului;

\item și descărcarea proiectului în format \acr{ZIP}.

\end{itemize}

\subsubsection{Duplicarea}

Duplicarea proiectului nu este costisitoare pentru server (explicat la secțiunea
\ref{filestoresec}, pagina \pageref{filestoresec}) și din acest motiv ea este
încurajată.

Dacă proiectul a fost duplicat din altul, este afișată legătura către proiectul
părinte.

La secțiunea \ref{mulverssec} de la pagina \pageref{mulverssec} se discută cum
poate fi folosită duplicarea pentru editare colaborativă.

\subsubsection{Descărcare}

Cu butonul de descărcare se poate lua doar versiunea curentă a proiectului.
Descărcarea versiunilor vechi poate fi făcută din istoric. La fel și duplicarea
sau vizualizarea versiunilor vechi.

\subsubsection{Colaboratori}

Din pagina proiectului se poate face și administrarea setului de colaboratori
(cei care pot edita proiectul curent în totalitate). Implicit, doar creatorul
este listat și doar el poate să adauge și să șteargă alți utilizatori.

Intuitiv nu are sens să fie afișat și autorul deoarece nu poate fi șters, dar
așa se poate afla instant că acolo este lista de colaboratori și de acolo pot fi
adăugați.

\subsection{Istoric}

Istoricul conține legături spre versiunile fișierelor

Pagina de istoric a unui proiecte listează toate versiunile sale. O versiune
afișează:

\begin{itemize}

\item numele versiunii și legături către pagina versiunii și opțiuni de
descărcare;

\item lista de autori a versiunii (cei care au făcut o modificare oricât de mică
de la ultima versiune);

\item un rezumat al modificărilor făcute asupra proiectului (ce fișiere au fost
modificate, șterse etc)

\item și alte metadate scurte.

\end{itemize}

Pagina unei versiuni vechi este aproape identică cu pagina proiectului la
starea la care s-a făcut \eng{commit}-ul.

\subsection{Fișiere}

Listarea fișierelor este prezentă pagina proiectului, pagina de versiune și
în listarea conținutului fișierului însăși.

Pentru listarea fișierelor este folosită colorarea sintactică pe parte de client
folosind o bibliotecă JavaScript. Pe lângă lângă recunoașterea fișierelor text mai
sunt afișate și un număr de imagini suportate de \LaTeX{}.

\subsection{\acr{URL}-uri}

Cred că proiectarea \acr{URL}-urilor este importantă pentru că ajută la
folosirea mai ușoară a sitului. Un exemplu de situri cu \acr{URL}-uri bune este
GitHub unde dacă numele meu de utilizator este \cod{paul-nechifor} și numele la
un proiect este \cod{multilatex} \acr{URL}-ul pentru el este
\cod{github.com/paul-nechifor/multilatex}. Ceea ce este ușor de memorat și ușor
de transmis în medii non-electronice. A se compara cu alte variante des
întâlnite precum un ipotetic
\cod{github.com/projects.php?user=51234\&project=654742}.

Urmează exemple a \acr{URL}-urilor folosite unde \cod{:nume} reprezintă o
variabilă.

\begin{description}

\item[\cod{/}] Pagina principală.

\item[\cod{/api/...}] Toate paginile de folosite de \acr{API}.

\item[\cod{/blog}] Cele mai recente articole din blog.

\item[\cod{/blog/:post}] Un articol specific.

\item[\cod{/explore}] Pagina de explorare a galeriei de proiecte.

\item[\cod{/:username}] Pagina personală a unui utilizator.

\item[\cod{/:username/:location}] Pagina unui proiect.

\item[\cod{/:username/:location/commit/:n}] Pagina unui proiect la o anumită
versiune (\eng{commit}).

\item[\cod{/:username/:location/commit/:n/fork}] \acr{URL}-ul de duplicare a
unui proiect la o anumită versiune.

\item[\cod{/:username/:location/head/pdf}] Vizualizarea documentului compilat
(varianta curentă din editor).

\item[\cod{/:username/:location/head/log}] Vizualizarea logului de compilare.

\item[\cod{/:username/:location/zip}] Descărcarea proiectului în format \acr{ZIP}.

\end{description}

\subsection{Dispozitive mobile}

Datorită creșterii utilizării dispozitivelor mobile pe web
(figura~\ref{mobilefig}) este important să fie luate în considerare.

Pentru realizarea sitului am utilizat o proiectare web adaptabilă
(\eng{responsive}) folosind interogări \cod{@media}. Singura excepție este
pagina editorului deoarece necesită un ecran mare. Pot fi observate diferențele
în figura~\ref{desktopsitefig} (desktop) și figura~\ref{mobilesitefig} (mobil).

\begin{figure}[hb]
\begin{center}
\begin{tikzpicture}
    \begin{axis}[
        width=0.9\textwidth,
        height=4cm,
        ymajorgrids,
        x tick label style={/pgf/number format/1000 sep=},
        ytick scale label code/.code={},
        max space between ticks=50pt,
    ]
        \addplot table[x=in,y=out]{statcounter.csv};
    \end{axis}
\end{tikzpicture}
\end{center}
\caption{Utilizarea dispozitivelor mobile pe Web (ca procent)\cite{statcount}.}
\label{mobilefig}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=16cm]{imagini/desktop}
\end{center}
\caption{Situl vizualizat în format pentru desktop.}
\label{desktopsitefig}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=7cm]{imagini/mobile}
\end{center}
\caption{Situl vizualizat în format pentru dispozitive mobile.}
\label{mobilesitefig}
\end{figure}

\subsection{Stil}

Stilul sitului nu se numără printre cele mai importante aspecte și am ales să
folosesc Bootstrap 3 cu puține modificări pentru o estetică plată și simplă.

\section{Integrare continuă}

\idee{TODO}

\section{Construirea}

Construirea proiectului a susținut cele mai mari modificări și a trecut prin
trei variante. Prin construire mă refer la compilarea, configurarea și
instalarea părților necesare.

\subsection{Programul propriu}

Inițial am început prin a scrie propriul program pentru a face construirea.
Programul folosea pachetul \cod{commander} pentru a procesa argumentele (spre
exemplu pentru a suprascrie opțiuni din fișierul de configurație) și avea
opțiunile de a instala și de a face lansarea.

Instalarea implica copierea fișierelor prin \cod{rsync}, crearea dosarelor
speciale și repornirea serviciului Upstart. Atunci nu făceam compilare de niciun
fel.

Lansarea implica copierea dosarului de dezvoltare pe un sistem specificat și
rularea scriptului de instalare.

După asta am descoperit Grunt care rezolvă această problemă într-un mod general.

\subsection{Grunt}

Grunt este un sistem de automatizare a proceselor de lucru cu foarte multe
\eng{plugin}-uri care funcționează prin descrierea de sarcini de lucru.

Un avantaj peste folosirea de fișiere \cod{Makefile} este că Grunt este scris în
JavaScript și modulele sunt făcute să fie independente de platformă.

\subsubsection{Compilare Stylus}

Fișierele Stylus pot fi compilate la \eng{runtime} de Express, dar este mai
eficient să fie compilate dinainte în CSS.

\subsubsection{Unificare JavaScript}

În mod normal fișierele JavaScript sunt incluse individual in pagini prin
etichete \cod{script}. Acest lucru obligă trimiterea unei cereri pentru fiecare
fișier. În HTTP~1.1, nu mai este necesară crearea unei conexiuni noi per
cerere, dar tot există \eng{overhead} pentru cereri.

O altă problemă este lipsa de modularizare. Un modul logic compus din mai multe
fișiere JavaScript trebuie inclus în fiecare pagină. Astfel pot exista coliziuni
de variabile și includerea etichetelor \cod{script} în ordine greșită poate duce
la erori.

Pachetul Browserify permite compunerea fișierelor JavaScript într-unul singur
folosind specificația CommonJS de descriere a modulelor (cea folosită și de
Node). Astfel, în loc să fie descris un pachet în mod liniar prin etichete
\cod{script} în fiecare pagină în care este inclus, fiecare fișier descrie ce
dependințe are și Browserify compune tot codul necesar în funcție de fișierul de
intrare și dependințele acestuia în mod recursiv.

Un dezavantaj la acest mod de lucru este că se complică procesul de depanare
deoarece nu mai corespund liniile la \eng{runtime} cu liniile din fișierele
proiectului. Din fericire acest lucru este rezolvat prin folosirea de mapări la
sursă (\eng{source maps}) unde pe lângă codul modulului unificat este inclusă în
comentarii și maparea la codul inițial. Însă recunoașterea mapărilor este
prezentă doar în navigatoarele recente.

\subsubsection{Minificare}

Pentru fișierele JavaScript și CSS se poate realiza o optimizare prin care se
scot toate spațiile și comentariile inutile. Operații mai avansate de optimizare
reprezintă redenumirea variabilelor locale la JavaScript sau eliminarea de cod
nefolosit (cod după \cod{return} în JavaScript sau opțiuni suprascrise de mai
multe ori la CSS).

\subsubsection{Instalarea și lansarea}

De data aceasta pașii pentru instalare sunt descriși în JavaScript. După
compilarea fișierelor, ele sunt copiate în dosarul necesar (folosind \cod{rsync}
pentru evitarea copierii fișierelor neschimbate) și se execută restul pașilor
(crearea dosarelor și utilizatorilor dacă e nevoie, repornirea serviciului).
Lansarea este similară variantei precedente.

\subsubsection{Altele}

Alte sarcini descrise sunt de compilare a șabloanelor de proiecte \LaTeX{} și
listarea fișierelor de logare în timp real de pe mașina țintă.

\subsubsection{Problema}

Problema la Grunt este că preferă configurația înainte de cod. Acest lucru duce
la configurații mari și organizate pe operații în loc de ordinea logică a
construirii.

\subsection{Gulp}

Gulp este un sistem de automatizare similar, dar cu diferența principală că
sarcinile sunt descrise prin fluxuri de transformare și se preferă cod înainte
de configurații stufoase.

Astfel construirea proiectului poate fi descrisă printr-un graf de dependințe și
transformări din care se execută doar cele necesare.

\idee{TODO: graficul cu transformările}

\subsubsection{CoffeeScript}

A treia iterație a fost și momentul în care am început să folosesc CoffeeScript.
Însăși fișierul de configurare Gulp este scris în acest limbaj. Browserify poate
fi făcut să recunoască fișiere CoffeeScript și să le compileze înainte de
unificare.

\subsubsection{Bower}

Începând cu mutarea la Gulp am început să folosesc și Bower (discutat la
secțiunea~\ref{bowersub}, pagina~\pageref{bowersub}) pentru administrarea
pachetelor pentru \eng{front-end}.

\section{\eng{Back-end}}

Pe partea de server am folosit următoarele aplicații/tehnologii:

\begin{itemize}

\item \textbf{Vagrant}, pentru administrarea mediului de lucru;

\item \textbf{Upstart}, pentru descrierea serviciului Linux sub care rulează
aplicația web

\item \textbf{Node.js}, pentru aplicația web;

\item \textbf{Express.js}, pentru \eng{framework}-ul web;

\item \textbf{Jade}, pentru șabloane HTML;

\item \textbf{Stylus}, pentru generarea CSS;

\item și \textbf{MongoDB} pentru baza de date.

\end{itemize}

\subsection{Vagrant}
\label{vagrantsub}

Dezvoltarea Web, mai mult decât alte tipuri, necesită folosirea a unei
multitudini de tehnologii disparate sau strâns legate. Configurarea lor poate fi
problematică și a dus la separarea în specializări de dezvoltare și operare
\acr{IT}.

O soluție este să se folosească mașini virtuale cu tot \eng{software}-ul
instalat. Însă acest mod de lucru încetinește pasul de dezvoltare și necesită
trafic mult: dacă se schimbă o piesă, durează mult timp până se reconfigurează
sistemul virtual și până este transmis la toți dezvoltatorii.

Vagrant este un sistem de a lucra cu și de a partaja medii de dezvoltare
virtuale care rezolvă această problemă într-un mod diferit. Un sistem virtual
este descris într-un singur fișier cu toate proprietățile sale cum ar fi:

\begin{itemize}

\item imaginea sistemului de operare de bază (neconfigurat);

\item specificarea sistemului virtual (mărime \acr{RAM}, număr de procesoare
etc);

\item specificarea rețelei interne (adrese \acr{IP} folosite, redirectare
porturi etc);

\item modul de provizionare, fie prin scripturi de sistem sau folosind folosind
programe avansate (Chef, Puppet);

\item și altele.

\end{itemize}

Multe imagini de sisteme de operare sunt făcute publice și duplicate local. Prin
urmare, transferul unui mediu de lucru nou deseori necesită doar copierea unor
fișiere text și reprovizionarea.

În mod normal se instalează sisteme de operare Linux pentru server care rulează
fără un afișaj grafic și deci toată comunicarea se realizează prin \acr{SSH}.

Vagrant folosește implicit VirtualBox pentru virtualizare, dar pot fi folosiți
și alți furnizori cum ar fi VMware (pentru care pot fi folosite opțiuni de
configurare specializate).

Un alt avantaj este că Vagrant suportă și lansarea pe medii de lucru non-locale
cum ar fi Amazon EC2. Acest lucru înseamnă că poate fi folosit pentru
dezvoltare, dar și pentru lansare în producție.

Imaginea sistemului de operare pe care o folosesc este Ubuntu 12.04 deoarece era
varianta cu suport pe termen lung când am început proiectul.

Pentru provizionare folosesc un script deoarece n-am nevoie de funcționalități
mai avansate. În principal provizionarea consistă din:

\begin{itemize}

\item actualizarea pachetelor sistemului (pentru securitate);

\item instalarea versiunilor cele mai recente de MongoDB și Node de la furnizori
(nu din Ubuntu);

\item instalarea distribuției \LaTeX{} \cod{texlive-full} care are peste 2~GiB;

\item și instalarea altor pachete folosite de aplicație.

\end{itemize}

\subsection{Upstart}

Programul construit rulează pe \eng{backend} ca un serviciu în Upstart. Upstart
este un sistem de administrare a serviciilor pentru Unix bazat pe evenimente. El
a fost proiectat ca un înlocuitor pentru init.

Am ales Upstart pentru că este instalat inițial în Ubuntu 12.04. Din următoarele
versiuni, însă, Ubuntu și Debian se vor schimba la Systemd care are mai multe
funcționalități.

Eu folosesc Upstart prin scriptul care specifică:

\begin{itemize}

\item ce utilizator să fie folosit pentru executarea programului (ca să nu fie
utilizat \cod{root} pentru siguranță;

\item cum să repornească serviciul în caz de erori (se abandonează repornirea în
cazul în care eșuează mai multe de 10 ori în 5 secunde);

\item spre ce fișier de logare să fie redirectate ieșirile.

\end{itemize}

\subsection{Node}

\idee{TODO}

\subsection{Express}

Express este un \eng{framework} de aplicații web pentru Node făcut să fie
minimal și flexibil. El este modular și nu include funcționalități statice cum
ar fi motoare de șablonare unice, dosare statice predefinite etc. O aplicație
Express poate chiar fi definită într-un singur fișier.

Deoarece este un nivel foarte mic peste Node, nu reduce din performanța
acestuia.

\subsection{Jade}

Jade este un motor de șablonare pentru Node cu sintaxă bazată pe indentare.

Exemplu de cod Jade:

\begin{verbatim}
mixin authors(list)
  p.authors(class=list.length > 1 ? 'multiple-authors': null)
    each names in list
      span.names= names.join(' ')

#container
  p Primul <em>paragraf</em>.
  .project: +authors([['Paul', 'Nechifor']])
  .project: +authors([['Nechifor'], ['<nume>']])
\end{verbatim}

Rezultatul pe care îl produce:

\begin{verbatim}
<div id="container">
  <p>Primul <em>paragraf</em>.</p>
  <div class="project">
    <p class="authors"><span class="names">Paul Nechifor</span></p>
  </div>
  <div class="project">
    <p class="authors multiple-authors">
      <span class="names">Nechifor</span>
      <span class="names">&lt;nume&gt;</span></p>
  </div>
</div>
\end{verbatim}

Funcționalități demonstrate în cod:

\begin{itemize}

\item etichetele nespecificate sunt implicit de tip \cod{div};

\item folosirea de cod JavaScript pentru valori;

\item se poate folosi și sintaxa \acr{HTML} standard (\cod{<em>}).

\end{itemize}

Deoarece Jade are sintaxă cu spații semnificative, ele nu fac parte din codul
emis. În rezultatul afișat, spațiile sunt adăugate doar pentru a fi mai ușor
de citit, dar în mod normal codul produs nu conține niciun spațiu în plus.

\subsection{Stylus}

Stylus (2010) este un limbaj \eng{stylesheet} care compilează în CSS. Este
asemănător cu Sass (2007) și LESS (2009), dar cu diferența principală că este
mult mai succint și este bazat pe indentare. Totuși, Stylus suportă și sintaxa
CSS.

Exemplu de cod Stylus:

\begin{verbatim}
main-color = #f7a
main-size = 18px

a, code
  color main-color
  font-size main-size
  @media (max-width: 479px)
    font-size floor(main-size * 0.8)
  &:hover
    color lighten(main-color, 20%)
\end{verbatim}

Rezultatul care va fi produs:

\begin{verbatim}
a, code {
  color: #f7a;
  font-size: 18px;
}
@media (max-width: 479px) {
  a, code { 
    font-size: 14px;
  }
}
a:hover, code:hover {
  color: #ff92bb;
}
\end{verbatim}

În acest exemplu se folosește o variabilă \cod{main-color} pentru culoare care este și
manipulată pentru \cod{:hover} (înălbită cu 20~\%). Folosind \cod{main-size}
mărimea textului pe dispozitive cu ecran mic este micșorată la 80~\%. Este
demonstrată și imbricarea care evită repetarea: se folosește doar \cod{\&:hover}
în loc de \cod{a:hover, code:hover}.

\subsection{MongoDB}

\idee{TODO}

\section{\eng{Front-end}}

Pe partea de client am folosit următoarele tehnologii/aplicații:

\begin{itemize}

\item \textbf{Backbone} pentru paradigma \acr{MVC} pe client;

\item \textbf{jQuery} (cu anumite plugin-uri) pentru compatibilitate mai mare pe
diferite navigatoare;

\item \textbf{Ace}, ca editor de cod în pagini web;

\item și \textbf{\acr{PDF}.js}, pentru randarea și vizualizarea documentelor
\acr{PDF}.

\end{itemize}

\subsection{Backbone.js}

Backbone.js\cite{backbone} este o bibliotecă JavaScript pentru partea de client
care furnizează paradigma model--view--controller (\acr{MVC}).

În principal, Backbone este făcut pentru aplicații cu o singură pagină.

Backbone are o mărime foarte mică. Comprimat, are doar 6,5~\acr{KiB}. Spre
diferență de alte \eng{framework}-uri, Backbone e făcut să fie foarte simplu și
nu este cuplat strâns. Deci poate fi folosit cu multe alte biblioteci fără să
necesite controlarea întregului \acr{DOM}.

\subsection{jQuery}

jQuery este o bibliotecă JavaScript care simplifică programarea pe partea de
client și rezolvă parțial lipsa de compatibilitate între diferitele platforme.

\subsection{Ace}
\label{acesub}

Ace\cite{ace} este un editor de text \eng{open source} făcut de Cloud9 care
poate fi incorporat în pagini \acr{HTML}.

Este făcut specific pentru editare de cod și suport o multitudine de limbaje
(printre care și \LaTeX{}).

Editorul este scris în JavaScript și folosește \acr{DOM}-ul pentru afișare. Ace
este succesorul proiectului Mozilla Skywriter care folosea \cod{canvas} pentru
afișare.

El este modular și poate fi extins. Datorită acestul lucru am putut să folosesc
plugin-ul de la ShareJS pentru editare colaborativă.

\subsection{\acr{PDF}.js}

\acr{PDF}.js\cite{pdfjs} este o bibliotecă JavaScript care poate să randeze documente
\acr{PDF} pe partea de client fără folosirea de cod nativ. Proiectul este
dezvoltat de Mozilla. Pentru randarea paginilor \acr{PDF}.js folosește eticheta
\cod{canvas}.

Printre avantajele lui se numără:

\begin{itemize}

\item Este bun pentru securitate pentru că nu se mai execută cod nativ în
randarea documentelor \acr{PDF}. Spre exemplu Adobe Acrobat Reader a avut un
număr mare de vulnerabilități.

\item Poate fi manipulat din alt cod JavaScript. Un plugin nativ nu poate fi
controlat la fel de ușor (spre exemplu folosind eticheta \cod{iframe}) în primul
rând datorită faptului că sunt multe platforme și nu toate au un \acr{API} prin
care pot fi controlate.

\end{itemize}

Un dezvantaj mare este că randarea este prea înceată pentru a nu fi
perceptibilă. Acest lucru este agravat la documente foarte mari.

\section{Comun \eng{back-end} și \eng{front-end}}

Comun pentru client și server este:

\begin{itemize}

\item \textbf{Bower} care-i folosit pentru administrarea pachetelor pentru
\eng{front-end};

\item \textbf{WebSocket} prin care se face comunicarea dintre editor și server;

\item și \textbf{ShareJS} care-i folosit pentru editarea colaborativă a
fișierelor.

\end{itemize}

\subsection{Bower}
\label{bowersub}

În variantele precedente am inclus codul pentru modulele necesare (Ace,
\acr{PDF}.js etc) direct în codul sursă a proiectului. Acest lucru duce la
supradimensionarea proiectului cu cod care nu-mi aparține. Pentru foarte mult
timp acest mod de lucru era normal pentru că nu exista un mod de a administra
pachetele \eng{front-end}.

Bower este un astfel de manager de pachete pentru web. Spre diferență de
\acr{NPM} și altele Bower nu este un manager de pachete pentru un limbaj
specific. El funcționează pentru orice tip de fișiere: JavaScript, \acr{HTML},
\acr{CSS} și altele. În acest caz Bower definește un pachet ca orice colecție de
fișiere și lasă modul de folosirea a codului pentru utilizatori. Bower se
folosește de repozitorii de tip Git pentru răspândirea fișierelor.

În acest fel am putut să mut codul pentru dependințele de front-end în afara
proiectului. Un avantaj aici este că pot să am un istoric separat. Dacă trebuie
să actualizez la un pachet mai nou nu trebuie să includ tot codul modificat ci
doar trebuie să specific versiunea nouă în fișierul de configurare Bower și să
fac actualizarea locală.

\subsection{WebSocket}
\label{websocketsub}

WebSocket este un protocol de comunicare \eng{full-duplex} în principal
implementat pentru comunicarea cu navigatoare web. Specificația WebSocket a fost
standardizată în 2011 și face parte din grupul de funcționalități \acr{HTML5}.

WebSocket are mai multe avantaje peste versiunea de comunicarea Comet sau Ajax:

\begin{itemize}

\item se reduce traficul și latența deoarece nu trebuie retrimis tot antetul
HTTP de mai multe ori;

\item se poate face comunicare bidirecțională printr-o singură conexiune;

\item permite trimiterea de mesaje text sau binare, nu doar de flux de caractere
ca la HTTP.

\end{itemize}

În plus, datorita faptului că se folosește tot portul 80 se păstrează
caracteristicile de securitate (el fiind rar blocat).

În prezent, toate navigatoarele moderne suportă protocolul WebSocket.

\subsection{ShareJS}
\label{sharejssub}

ShareJS este \eng{framework} pentru editarea colaborativă a fișierelor text.
Este compus dintr-o bibliotecă pentru partea de client și un pachet pentru Node.

Pentru permanența fișierelor, ShareJS folosește mai multe tipuri de baze de
date.

În mod normal comunicarea dintre client și server se poate face prin WebSocket,
dar dacă nu este disponibilă se poate face și folosind comunicarea Comet.

Pentru menținerea modelului de consistență este folosită tehnologia operational
transformation (\acr{OT}).

\section{Autentificare}

Stocarea incorectă a parolelor încă este o problemă des întâlnită astăzi și a
dus la compromiterea a milioane de conturi pentru multe companii (vezi
tabelul~\ref{paroletab}).

Eu am folosit \eng{hashing} a parolei cu \eng{salt} (data înregistrării). O altă
variantă ar fi fost bcrypt, dar verificarea este mai computațional intensivă.

\begin{table}[hb]
\begin{center}
\begin{tabular}{l l r r}
Data & Compania & Parole unice & Parole totale \\
\hline
2012-07-11 & Yahoo & 342.508 & 442.832 \\
2012-02-22 & YP & 833.994 & 1.566.156 \\
2009-12-04 & RockYou & 14.344.173 & 32.603.145 \\
2011-12 & CSDN & 4.037.902 & 6.428.632 \\
\end{tabular}
\end{center}
\caption{Compromiterea parolelor stocate în clar\cite{passleak}.}
\label{paroletab}
\end{table}

\subsection{Sugestii}

Unele situri folosesc sau chiar obligă folosirea de sugestii pentru amintirea
parolelor. Eu nu am făcut asta deoarece în cazul compromiterii bazei de date
acest lucru ajută la găsirea parolelor. Acest lucru s-a întâmplat în 2013 când
hash-urile și sugestiile pentru 150 de milioane de conturi Adobe au fost
publicate. Deoarece nu se folosea \eng{salt}, dacă mai mulți utilizatori aveau
aceeași parolă, sugestiile ajută la ghicirea parolei.

\subsection{Părți terțe}

O variantă de autentificare este folosirea unor părți terțe. Eu nu am făcut asta
pentru că acest lucru implică dependența de alte sisteme care pot încetini
dezvoltarea rapidă.

\subsection{Înregistrare rapidă}
\label{inregrapsub}

În loc să permit autentificarea cu conturi de pe alte situri, am ales să permit
înregistrarea foarte rapidă. De pe prima pagina se poate realiza înregistrarea
scriind doar numele dorit și parola (și confirmarea ei).

\subsection{Probleme}

Deoarece nu am un certificat, încă nu folosesc HTTPS pe \cod{multilatex.com},
deci autentificarea nu este foarte sigură.

\section{Izolare \LaTeX}

\TeX{} este un limbaj puternic și deci posibil periculos. Trebuie avut grijă când
se execută cod arbitrar de la surse necunoscute.

Am scris un modul care să izoleze (\eng{sandboxing}) pe cât posibil compilarea
proiectelor \LaTeX{}.

\subsection{Execuția comenzilor de sistem}

Una dintre primele probleme este că \LaTeX{} poate să execute comenzi de sistem
arbitrare folosind construcția \cod{\textbackslash write18\{comandă\}}.

În mod normal acestă construcție nu este disponibilă, dar pentru mai mare
siguranță poate fi oprită direct din execuția \cod{pdflatex} cu argumentul
\cod{-no-shell-escape}. \poate{Se mai folosește în plus argumentul
\cod{-halt-on-error} pentru a se opri execuția programului în loc să aștepte
corectarea interactivă a erorilor.}

\subsection{Cod rău-intenționat}

\TeX{} este un limbaj Turing-complet\cite{basictc} deci nu se poate determina fără a fi fie
executat codul dacă compilarea documentului se va termina.

\LaTeX{}, cu toate pachetele sale, este uriaș, deci foarte probabil există
probleme nedescoperite care pot duce la umplerea memoriei sau intrarea în bucle
infinite.

Problema terminării poate fi ameliorată prin folosirea unui \eng{timeout} pentru
compilarea documentelor, dar acest lucru poate fi problematic pentru documente
foarte mari.

În plus, se folosește un utilizator special pentru execuția programului
\cod{pdflatex} astfel încât să fie limitată compromiterea procesului prin codul
rulat.

Acest lucru permite în Linux și setarea de limite:

\begin{itemize}

\item spre unde poate scrie un utilizator;

\item câtă memorie virtuală poate utiliza (folosind \cod{ulimits});

\item cât timp de CPU poate folosi, și altele.

\end{itemize}

Codul rău nu este în mod necesar malițios deci un utilizator trebuie prezentat
cu o eroare în loc să fie interzis.

\subsection{Altele}

Mai sunt alte feluri în care se poate influența sistemul, spre exemplu prin
scrierea de fișiere folosind pachetul \cod{newfile}. Așa se poate umple sistemul
de fișiere. Și această problemă este rezolvată prin setarea de limite pe
utilizator.

\section{Compilator \LaTeX}

La momentul de față modulul pentru compilarea \LaTeX{} face parte din aplicația
web.

Compilarea documentelor \LaTeX{} este partea cea mai costisitoare din punctul de
vederea al procesorului, deci ar trebui extrasă într-un serviciu separat
(discutat în secțiunea~\ref{comlatsec} de la pagina~\pageref{comlatsec}).

\section{Structura proiect}

În baza de date un proiect conține:

\begin{itemize}

\item metadate de utilizare (data creației, număr de vizualizări etc);

\item autorul principal sub care este listat proiectul;

\item setul de colaboratori care pot edita proiectul;

\item lista de versiuni (cu toate fișierele în \eng{file store});

\item locația dosarului de lucru (denumit \eng{head}) unde este stocată starea
curentă a proiectului;

\item lista de fișiere sursă;

\item și alte câmpuri.

\end{itemize}

Dosarul de lucru trebuie să existe din motivele listate la
secțiunea~\ref{memstasub} de la pagina~\pageref{memstasub}. El poate fi accesat
din editor doar de către colaboratori și este făcut public când este făcută o
nouă versiune din starea curentă (\eng{commit}).

Este important să fie enumerate fișierele sursă în baza de date pentru a fi
distinse de cele generate de \LaTeX{}. Fișierele generate trebuiesc ignorate la
incluziunea în istoric. Singura excepție este însăși fișierul \acr{PDF} rezultat
care este inclus separat.

Fiecare fișier sursă are un cod numeric. Inițial foloseam însăși calea
fișierului drept cod (spre exemplu în comunicarea dintre colaboratori la
editare), dar acest lucru cauzează probleme la redenumire.

\section{Versionare}
\label{versionaresec}

Modul de memorarea a istoricului de editare este inspirat de Git. Mereu se
stochează fișierele noi rezultate și nu doar diferențele. Acest lucru duce la
folosirea a mai mult spațiu pe disc, dar se câștigă viteză pentru că nu
trebuiesc citite toate modificările intermediare pentru a se reconstrui o
anumită versiune. În secțiunea~\ref{filestoresec} de la
pagina~\pageref{filestoresec} arăt cum s-ar putea reduce acest lucru.

Ca și în Git, unitatea de bază este setul de modificare a proiectului și nu este
folosit un istoric separat pentru fiecare fișier în parte (cum se procedează la
\acr{SVN}).

Când se creează o nouă versiune a proiectului toate fișierele sursă sunt
introduse în \eng{file store} unde primesc și un cod (rezumatul \acr{SHA1}).
Dacă proiectul compilează cu succes, este introdus și \acr{PDF}-ul rezultat.

Pentru fiecare pagină din \acr{PDF} este făcută o miniatură. Miniatura dinamică
(explicată în secțiunea~\ref{galeriesub}, pagina~\pageref{galeriesub}) este
afișată pe pagina proiectului și în galerie.

Dacă fișierul a fost compilat cu succes, atunci se face și o arhivă \acr{ZIP} cu
conținutul proiectului. Arhiva poate fi folosită pentru exportare și conține și
documentul \acr{PDF} (dar nu și celelalte fișiere generate de \cod{pdflatex}).
Am ales formatul \acr{ZIP} pentru că este printre cele mai recunoscute.

Se poate face duplicare (\eng{fork}) la oricare versiune a unui proiect, nu doar
la versiunea cea mai recentă.

În baza de date o versiune conține:

\begin{itemize}

\item metadate specifice;

\item lista fișierelor sursă din \eng{file store} identificate după rezumatul
\acr{SHA1};

\item fișierul \acr{PDF} din \eng{file store} (dacă există);

\item arhiva \acr{ZIP} din \eng{file store} (dacă există);

\item lista fișierelor miniatură (\eng{file store});

\item lista de colaboratori care au contribuit la versiunea curentă;

\item lista de modificări efectuate față de versiunea precedentă (pentru a nu fi
calculate la fiecare a fișare în pagina web);

\item și altele.

\end{itemize}

\section{Notificări}
\label{notificarisec}

Pentru utilizatorii care editează concurent un proiect este foarte important să
poată comunica în mod direct. Din acest motiv am implementat notificările în
timp real care fac parte din editor. Notificările principale sunt de tip
\eng{chat}, dar sunt și cele generate automat din evenimente specifice (spre
exemplu când se face un \eng{commit} nou al proiectului).

În baza de date notificările sunt stocate doar prin lista de mesaje și
interpretarea lor este lăsată pentru editorul de pe partea de client.

În acest mod anumite mesaje pot fi adnotate. Spre exemplu, dacă un utilizator
trimite mesajul „Uită-te la conținut.tex:84.“, atunci fraza „conținut.tex:84“ va
fi o legătură la linia respectivă (și se deschide fișierul dacă este nevoie).

\section{\eng{File store}}
\label{filestoresec}

\eng{File store}-ul este o aplatizare a fișierelor din toate proiectele după
rezumatul \acr{SHA1}. El dispune de următoare le avantaje.

\begin{itemize}

\item Dacă la o versiune nouă nu se modifică un fișier (sau se revine la o
versiune mai vechi) nu trebuie stocat din nou.

\item Se reduce costul duplicării proiectelor (\eng{forking}) la aproape zero
pentru că nu este nevoie să fie creat niciun fișier nou la duplicare și până în
momentul separării au un istoric comun.

\item Oferă un nivel sporit de siguranță a datelor pentru că se poate verifica
în viitor corespondența dintre numele din \eng{file store} și rezumatul
\acr{SHA1} recalculat.

\end{itemize}

Toate fișierele sunt stocate într-un dosar, dar deoarece nu toate sistemele de
fișiere suportă un număr mare de fișiere într-un singur dosar, se realizează o
grupare după primele trei caractere din cod.

Deci \cod{45ad3b07...} este stocat în \cod{\$file\_store/45a/d3b07...}.

\section{Comunicare}

Comunicarea dintre editorul de pe partea client și serverul se face printr-un
\acr{RPC} prin protocolul WebSocket și colaborarea asupra unui fișier se face
folosind ShareJS (care la fel folosește WebSocket sau Comet).

\subsection{WebSocket}

Când un utilizator se conectează la pagina editorului se stabilește o conexiune
WebSocket (descris la secțiunea~\ref{websocketsub},
pagina~\pageref{websocketsub}) cu controlorul de pe server.

Dacă există mai mulți utilizatori conectați simultan aceștia sunt notificați de
schimbările celorlalți. Dacă sunt mai mulți care editează un fișier, editarea
lor este administrată prin ShareJS. În plus, ei pot comunica direct prin
notificări (vezi secțiunea~\ref{notificarisec} la
pagina~\pageref{notificarisec}).

Pe partea de server pentru comunicarea WebSocket folosesc pachetul Node numit
\cod{ws}. El are avantajul că imită comunicarea JavaScript de pe client.

\subsection{ShareJS}

ShareJS (descris la secțiunea~\ref{sharejssub}, pagina~\pageref{sharejssub})

\section{Editor}

Editorul (afișat în figura~\ref{editorfig}) este compus ca o aplicație care
folosește întreaga pagină. Deoarece necesită un ecran mare, editorul nu este
suportat și pe platforme mobile.

\begin{figure}[bh]
\begin{center}
\includegraphics[width=16cm]{imagini/editor}
\end{center}
\caption{Editorul}
\label{editorfig}
\end{figure}

El are și funcționalitatea de a fi folosit pe tot ecranul (\eng{fullscreen}).

Editorul este compus din patru părți: meniul, panoul de proiect, panoul de
editare și panoul de previzualizare.

Cele trei panouri principale sunt separate de marcaje de control. Panoul din
stânga (de proiect) poate fi ascuns în stânga prin marcajul de control și panoul
din dreapta (de previzualizare) poate fi ascuns în dreapta. Panoul de editare
este singurul care nu poate fi minimizat.

Editorul are mai multe setări care pot fi controlate fie prin meniu fie prin
controale. Setările sunt sincronizate în timp direct cu serverul și prin urmare
vor fi disponibile de fiecare dată când este redeschis documentul.

Inițial plănuiam să fie două nivele de setări: cele individuale și cele de
proiecte care să aibă prioritate. Însă au fost implementate doar cele
individuale.

Din meniu poate fi și compilat documentul \LaTeX{}.

\subsection{Meniu}

În meniu sunt organizate toate acțiunile care au efect asupra întregului
proiect. Pentru a fi mai compact, ele sunt reprezentate doar prin iconițe de tip
font. Iconițele afișează meniul text la \eng{hover}.

Funcționalitățile implementate în meniu sunt de:

\begin{itemize}

\item compilare a documentului \LaTeX{};

\item crearea unei versiuni noi (\eng{commit});

\item descărcarea proiectului în starea curentă (din pagina proiectului se
poate descărca doar cea mai nouă versiune);

\item vizualizarea fișierului de logare de la compilarea documentului (pentru
depanare);

\item și modificarea setărilor de editor.

\end{itemize}

\subsection{Proiect}

Panoul de proiect are ca rol să reprezinte starea curentă a proiectului dintr-un
punct înalt de vedere. În momentul de față el este compus din arborele de
fișiere și lista de notificări.

\subsubsection{Arbore de fișiere}

Arborele de fișiere reprezintă lista curentă de fișiere a proiectului și ceea ce
se poate realiza cu fiecare fișier. Acțiunile asupra fișierelor sunt afișate
doar când este selectat un fișier sau se efectuează operația de \eng{hover}
asupra lui.

Proiectul este reprezentat ca rădăcina fișierelor. De acolo pot fi controlate și
acțiunile care pot fi efectuate asupra lui.

Acțiunile disponibile sunt afișate doar când sunt necesare pentru a nu confuza.

\subsubsection{Notificări}

Panoul de notificări conține toate notificările proiectului care este editat în
mod curent. Tipurile de notificări sunt discutate la
secțiunea~\ref{notificarisec} de la pagina~\pageref{notificarisec}.

\subsection{Editare text}

Panoul de editare de text este cel care conține editorul Ace (descris la
secțiunea~\ref{acesub}, pagina~\pageref{acesub}). Acesta este configurat special
pentru editarea de fișiere de tip \LaTeX{} cu tot cu colorarea sintactică. Alte
tipuri de setări ale editorului pot fi accesate din meniu.

\subsection{Previzualizare}

Panoul de previzualizare este cel care conține paginile randate prin
\acr{PDF}.js. Paginile sunt recreate de fiecare dată când este compilat
documentul \LaTeX{}. Deoarece paginile sunt create ca imagini în etichete
\cod{canvas} ele trebuiesc recreate când se redimensionează mărimea panoului
pentru că altfel n-ar fi la fel de clare.

\section{Șabloane}
\label{sabloanesec}

Proiectul conține și o listă de șabloane precompilate cu rolul de:

\begin{itemize}

\item a demonstra imediat posibilitățile de documente care pot fi create cu
\LaTeX{};

\item a testa rapid funcționalitătile și modul de lucru oferit de Multilatex;

\item și de a constitui un punct de plecare pentru diferitele tipuri de formate
suportate (pentru a fi duplicate ușor).

\end{itemize}

Ele au fost alcătuite din proiecte \LaTeX{} libere de pe internet cu scopul de a
acoperi o arie cât mai largă a tipurilor de documente care pot fi editate cu
\LaTeX{} și anume: eseuri, articole, cărți, raporturi și prezentări Beamer.

Inițial șabloanele făceam parte din proiect, dar odată cu mutarea dependințelor
Bower în afară am mutat și șabloanele ca un modul separat care este inclus în
proiect prin funcționalitatea submodule din Git. Astfel se pot dezvolta în
paralel și pot fi folosite și pentru alte proiecte.

\chapter{Rezultate}

\idee{TODO}

\chapter{Îmbunătățiri}

În acest capitol discut o serie de îmbunătățiri care pot fi aduse proiectului.
Sunt multe feluri în care poate fi făcut mai bun, dar eu o să mă concentrez pe
cele care pot fi aduse proiectului în starea sa curentă.

\section{Compilator \LaTeX}
\label{comlatsec}

Datorită faptului că compilarea documentelor \LaTeX{} este partea cea mai
costisitoare, ea ar trebuie separată de aplicația web.

Metoda cea mai bună ar fi să creez un serviciu special de compilare a
documentelor \LaTeX{} care să fie scalabil. Acest lucru nu ar fi foarte greu
deoarece doar ar trebui să fie un \eng{wrapper} pentru utilizarea a
\cod{pdflatex}.

\section{\eng{File store}}
\label{filestoresec}

Există cel puțin două modalități prin care poate fi îmbunătățită metoda curentă:
se pot comprima fișierele și se poate refolosi fișierele din \eng{file store} în
dosarul de lucru.

\subsection{Comprimare}

Deoarece cele mai multe fișiere sunt de tip text, ele pot fi comprimate ușor.
În acest caz pot fi folosite sisteme de fișiere cu suport pentru comprimare
a fișierelor sau fiecare fișier să fie comprimat la scriere și decomprimat la
citire.

Însă aceste soluții nu ar fi chiar cele mai bune. O comprimare mai eficientă
ar ține cont de faptul că există diferențe mici între foarte multe fișiere.

Sistemele de fișiere care arhivează bine de obicei sunt read-only (SquashFS,
cramfs etc).

O variantă în acest caz ar fi scrierea unui sistem de fișiere virtual (folosind
FUSE pentru Linux) care să arhiveze doar fișierele text accesul la restul fiind
furnizat direct de disc prin folosirea unui union mount (spre exemplu cu
UnionFS).

\subsection{Legături}

Deoarece unele fișiere din dosarul de lucru se schimbă rar (mai ales cele
de dimensiuni mai mari cum ar fi resursele), o optimizare posibilă ar fi să se
folosească hard link-uri către fișierele din \eng{file store}. Bineînțeles,
legăturile trebuiesc înlocuite dacă se editează fișierul pentru a nu fi alterate
fișierele statice din \eng{file store}.

\subsection{Altele}

Alte modalități ar fi să fie șterse periodic fișierele generate care nu sunt
accesate de multe ori. La secțiunea \ref{versionaresec} de la
pagina~\pageref{versionaresec} explic că documentul \acr{PDF} și arhiva
\acr{ZIP} sunt create la fiecare \eng{commit}. Ele ar putea fi șterse și
recreate dacă este din nou nevoie de ele.

\section{Înlocuire ShareJS}

\chapter{Aplicații}

\section{Colaborare}

\section{Mai multe versiuni}
\label{mulverssec}

În Multilatex nu există \eng{branching} ca în Git sau alte sisteme de versionare
(pentru că ar complica sistemul) și din acest motiv duplicarea proiectelor este
motoda recomandată pentru a încerca lucruri noi în paralel.

Pentru a încerca o editare care modifică în mod radical documentul un utilizator
în poate duplica proiectul și poate să facă modificările cu mai multe
\eng{commit}-uri fără a intra în conflicte cu ceilalți colaboratori.

Dacă modificările sunt considerate bune ele pot fi incluse în proiectul
principal.

Chiar și autorul proiectului îl poate duplica pentru a încerca lucruri noi.

\capfara{Concluzii}

\idee{TODO}

\begin{thebibliography}{1}
\addcontentsline{toc}{chapter}{Bibliografie}

\bibitem{texweb}
\url{mirrors.ctan.org/systems/knuth/dist/tex/tex.web}

\bibitem{texwebpdf}
\url{brokestream.com/tex.pdf}

\bibitem{basictc}
Andrew Marc Greene, BASIX --- An Interpreter Written in TEX, TUGboat, Volume 11 (1990), No. 3

\bibitem{passleak}
\url{thepasswordproject.com/leaked\_password\_lists\_and\_dictionaries}

\bibitem{texlivejs}
\url{manuels.github.io/texlive.js}

\bibitem{statcount}
\url{gs.statcounter.com}

\bibitem{ace}
\url{ace.c9.io}

\bibitem{backbone}
\url{backbonejs.org}

\bibitem{majordist}
\url{en.wikibooks.org/wiki/LaTeX/Installation\#Distributions}

\bibitem{pdfjs}
\url{mozilla.github.io/pdf.js}

\end{thebibliography}

\end{document}
